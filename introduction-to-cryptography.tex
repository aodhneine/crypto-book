% Load our own simple class.
\documentclass[a4paper,10pt]{article}

% AMS packages that are the standard in LaTeX maths typesetting.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

% For .ttf and .otf fonts support.
\usepackage{fontspec}

% Import "common" packages.
\usepackage{common}
\usepackage{commonmth}

% Set enumerate labels to (i), (ii), (iii), etc.
\renewcommand\labelenumi{(\roman{enumi})}
\renewcommand\theenumi\labelenumi

\usepackage{fancyvrb}
%\usepackage[pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}
\usepackage{bookmark}
\usepackage{xcolor}
\usepackage{verbatim}
% \usepackage{newtxmath}
\usepackage{multicol}

\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\cll}[1]{\mathcal{#1}}
\newcommand{\xor}{\otimes}
\newcommand{\arri}[2]{[#1\,..\,#2]}

\definecolor{darkred}{rgb}{0.545098039,0,0}
\newcommand{\mtt}[1]{{\color{darkred} \mathtt{#1}}}

%\setmainfont[UprightFont = *, BoldFont = * Bold, ItalicFont = * Italic]{Noto Serif SemiCondensed}

\makeatletter
\newenvironment{epigraph}[1]
{\def\epigraph@quoteauthor{#1}%
  \itshape\list{}{\rightmargin\leftmargin}\item\relax}
{\endlist\par\normalfont\hfill\ \epigraph@quoteauthor\hspace*{\@tempdima}\par\bigskip}
\makeatother

\newenvironment{code}{\list{}{\rightmargin\leftmargin}\item\relax\endgraf\verbatim}{\endverbatim\endlist}

\def\labelitemi{--}

% Enable \verb in footnotes.
\VerbatimFootnotes

% Enable bookmarks.
\bookmarksetup{startatroot}

\title{Introduction to Cryptography}
\author{Chloe}
\date{\today}

\begin{document}

% Create title.
\maketitle

\tableofcontents

\section*{Introduction}

This book---though it would be better to call it a paper---is inspired and based
on books ``A Graduate Course in Applied Cryptography''\footnote{\verb|https://toc.cryptobook.us/|}
by Dan Boneh and Victor Shoup, ``Crypto 101''\footnote{\verb|https://www.crypto101.io/|}
by lhv, and ``The Joy of Cryptography''\footnote{\verb|https://web.engr.oregonstate.edu/~rosulekm/crypto/|}
by Mike Rosulek.

\subsection*{Kerckhoffs' Principle}
When designing a cryptographic algorithm, it might be tempting to simply hide
all details of its working from third-parties to make it secure. However, this
is a red herring, as it imposes three major issues. One, in case should those
details get known, the only way to fix the security breach is to invent a
completely new algorithm. Second, if you want to use such algorithm for
communicating with more than one person, you have to invent new algorithm for
every communication you want to have, otherwise users would able able to read
each other messages. And third, as it turns out, in real world cryptographic
algorithms are always going to be known.

Thus, in order to make it secure, we should introduce an element to this system
that stays secret at all times, but at the same time can be easily generated by
the parties (as compared to creating a new algorithm). This principle is called
\itl{Kerckhoffs' Principle} and was formulated in 1883 as

\begin{quotation}
  \itshape
  Design your system to be secure even if the adversary has complete knowledge
  of its algorithms.
\end{quotation}

Such an element is called the \itl{secret key}. It is simple a (relatively)
small piece of data given to both encryption and decryption functions.

\subsection*{What is not relevant?}
During the course of this book, we are not going to adress sevral of the things
that are broadly relevant to cryptography, but are not strictly it.

\begin{itemize}
\item  We do not care whether the fact that Alice and Jenn are trying to
  communicate, only if the contents of the message are hidden. Obscuring the
  existence of the communication itself is called \itl{steganography}.
\item We will not consider reliablity of ciphertext getting from Alice to Jenn.
  Instead we just take it for granted. This issue is tackled by network
  protocols such as TCP.
\item We will not consider how parties keep their secret keys secret, even
  after estabilishing it.
\end{itemize}

\subsection*{Notation}
We will write $\set{\mtt{0},\mtt{1}}^n$ to denote the set of $n$-bit binary strings, i.e.
for $n = 3$, $\mtt{011}, \mtt{000}, \mtt{010}, ...$. When $s$ is a binary string, we will write
$|s|$ to denote the length in bits of $s$. We will also use a different font and
colour for bits.

\section{Shannon ciphers}
Shannon cipher is a pair $\cll{E} = (E, D)$ of functions, where
\begin{itemize}
\item $E$ is the \itl{encryption function} that takes as input key $k$ and a
  message $m$ and produces a ciphertext $c$, i.e. $c = E(k,m)$,
\item $D$ is the \itl{decryption function} that takes as input key $k$ and a
  ciphertext $c$ and produces a message $p$, i.e. $m = D(k,c)$.
\end{itemize}
Note, that we require that the decryption function produces the same message
that encryption function was provided with, i.e. $m = D(k, E(k, m))$.

For the rest of this section we are going to denote the set of all keys by $\cll{K}$,
the set of all messages by $\cll{M}$, and the set of all ciphertexts by $\cll{C}$.

Suppose Jenn wants to send a message to Alice, using some Shannon cipher. Jenn
encrypts a message $m \in \cll{M}$ with a shared key $k \in \cll{K}$ that both
of them know, obtaining $c \in \cll{C}$. Then she sends it to Alice, who uses
her copy of $k$ to decrypt it. This scenario assumes that the exchange of key
$k$ was done securely and no third-party get a hold of it. As we will see later,
this is rarely the case in the real world, and we are going to look into'
\itl{key exchange algorithms}.

\begin{example}
  A \itl{one-time pad} is a Shannon cipher $\cll{E}$, where the key, message,
  and length are all bit strings of the same length, i.e. $\cll{E}$ is defined
  over $\cll{(K,M,C)}$ such that $\cll{K} \equiv \cll{M} \equiv \cll{C} \equiv \set{\mtt{0}, \mtt{1}}^L$,
  for some fixed length $L$. Now, for a key $k \in \cll{K}$ and message
  $m \in \cll{M}$ the encryption function is defined as $E(k,m) = k \xor m$,
  and decryption function as $D(k,c) = k \xor c$, where $\xor$ is a bit-wise
  exclusive OR, i.e. a component-wise addition modulo 2.

  Here, the encryption and decryption are the same operation ($\xor$), but, again,
  as we will see, that is rarely the case.
\end{example}

\begin{example}
  A \itl{variable-length one-time pad} is a Shannon cipher $\cll{E}$ where the
  key is a bit string of a fixed length  $L$, and message and ciphertext are
  bit-strings of a variable-length, of length at most $L$. This properly can
  be described as follows: $\cll{K} \equiv \set{\mtt{0}, \mtt{1}}^L$ and $\cll{M} \equiv \cll{C} \equiv \set{\mtt{0}, \mtt{1}}^K$,
  where $K \leq L$. The encryption function $E$ for a message of length l is
  defined as $E(k,m) = k\arri{0}{l-1} \xor m$, and the decryption function $D$ for
  a ciphertext of length $l$ is defined as $D(k,c) = k\arri{0}{l-1} \xor c$, where
  $k\arri{0}{n}$ denotes the operation of taking first $n-1$ bits of $k$.
\end{example}

\begin{example}
  A \itl{substitution cipher} is something we are not going to talk about. Instead,
  search for it on Google, or DuckDuckGo, or Wikipedia, if you are interested.
\end{example}

However, Shannon ciphers are not practical and rarely used in real world. This
is because, for it to be \itl{perfectly secure}, a key must have the same length
as the message we are encrypting. That means that if Jenn wanted to send Alice a
1 gigabyte confidential video file, they would have to agree beforehand on a 1
gigabyte shared key.

\section{Stream ciphers}

\begin{epigraph}{David Kahn}
  Few false ideas have more firmly gripped the minds of so many intelligent men
  than the one that, if they just tried, they could invent a cipher that no one
  could break.
\end{epigraph}

In previous section we explored Shannon ciphers, which are a basic kind of
ciphers. However, they had a one issue---it wasn't feasible to use them with
long messages, as it would require having equally long private key. In this
section we are going to look into stream ciphers---a class of algorithms that
allows us to encode long messages using very short keys.

Recall the one-time pad, where the key, message, and ciphertext were all bit-
strings of length $L$. Instead we would want to have a much shorter $l$ ``seed'',
and then stretch it into $L$-bit padding using an efficient, deterministic
algorithm. This way parties would only need to transfer $l$-bit keys, and then
$L$-bit encoded messages.

For $s \in \set{\mtt{0},\mtt{1}}^l$ and $m,c \in \set{\mtt{0},\mtt{1}}^L$, we
define encryption and decryption functions as following: $E(s,m) = G(s) \xor m$
and $D(s,c) = G(s) \xor c$. Such modified function is called a \itl{stream cipher},
and the function $G$ is called a \itl{pseudo--random generator}.

We define a pseudo--random generator (PRG) as an efficient, deterministic
algorithm $G$, which computes and output $r$ from input seed $s$. Seed comes
from a finite \itl{seed space} $\cll{S}$, and output $r$ belongs to a finite \itl{output space}
$\cll{R}$. Usually $\cll{S}$ and $\cll{R}$ are of a predetermined length, such
as $\cll{S} = \set{\mtt{0},\mtt{1}}^l$ and $\cll{R} = \set{\mtt{0},\mtt{1}}^L$.
We say that $G$ is a PRN defined over $\cll{(S,R)}$.

We are not going to look into examples of PRGs here, as currently we do not have
enough knowledge to present them succinctly, nor is it in the scope of this book.
If you are interested in examples of good PRGs, see Scrambled Linear Pseudorandom
Number Generators\footnote{\verb|https://arxiv.org/abs/1805.01407|}, Squares: A
Fast Counter-Based RNG\footnote{\verb|https://arxiv.org/abs/2004.06278v3|}, or
Middle Square Weyl Sequence RNG\footnote{\verb|https://arxiv.org/abs/1704.00358v5|}.

\subsection{Encryption with PRG}
Let $G$ be a PRG defined over $(\set{\mtt{0},\mtt{1}}^l,\set{\mtt{0},\mtt{1}}^L)$.
The \itl{stream cipher} $\cll{E} = (E,D)$ \itl{constructed from} $G$ is defined
over $(\set{\mtt{0},\mtt{1}}^l,\set{\mtt{0},\mtt{1}}^j,\set{\mtt{0},\mtt{1}}^j)$,
where $j \leq L$. For $s \in \set{\mtt{0},\mtt{1}}^l$ and $m,c \in \set{\mtt{0},\mtt{1}}^j$,
the encryption function $E$ is defined as \[
  E(s,m) = G(s)\arri{0}{v} \xor m \text{,}
\] and the decryption function $D$ is defined as \[
  D(s,c) = G(s)\arri{0}{v} \xor c \text{,}
\]
where $v$ is either $|m| - 1$, if it is the encryption function, or $|c| - 1$,
if it is the decryption function.

\subsection{Attacks on the one-time pad}
Even though stream ciphers are semantically secure, they induce a lot of insecurity
if used incorrectly.

\subsubsection{Two-time pads}
A one-time pad stream cipher is fine for encrypting a single message from Jenn
to Alice. However, if Jenn wants to send multiple messages to Alice, she might
be tempted to use the same seed for encrypting both $m_1$ and $m_2$, like so
\begin{center}
  \(c_1 = G(s) \xor m_1\) and \(c_2 = G(s) \xor m_2\).
\end{center}
However, if we look into how messages are encrypted, taking into an account the
properties of XOR operation, we will see that an adversary could compute $\Delta_{c_1,c_2}$
by doing $\Delta = c_1 \xor c_2 = (G(s) \xor m_1) \xor (G(s) \xor m_2) = m_1 \xor m_2$.
As it turns out, natural languages have enough redundancy that given $m_1 \xor m_2$
they could easily compute both $m_1$ and $m_2$.

Such construction is usually jokingly called \itl{two-time pad}. As we just argued,
it is completely insecure. In particular, any stream cipher is vulnerable if
its key is used to encrypt more than one message. That said, throught the rest
of this book we will see many use cases where one-time ciphers are sufficient,
as for example when choosing a new random key for every message. However, in
settings when a single key must encrypt multiple messages, stream ciphers should
never be used directly. We are going to build such multi-use ciphers later.

\subsubsection{Malleability of one-time pads}
Even though stream ciphers are semantically secure, they provide no guarantees
that an adversary could not change a ciphertext and it would be detected by the
recipient. What's more, it lets us show that by modifing ciphertext, they could
change how decrypted message will change.

Suppose an adversary intercepts a ciphertex $c$. Then they change $c$ to become
$c' = c \xor \Delta$, for some $\Delta$ of their choice. Then, the receiving side
is being provided with the modified message $c'$, that they decrypt as
$D(s,c') = G(s) \xor c' = G(s) \xor c \xor \Delta = m \xor \Delta$.

This way attacker, without knowing neither $s$ nor $m$, is able to modify $c$
such that it becomes $m \xor \Delta$ (again for $\Delta$ of their choice). We
say that stream ciphers are \itl{malleable}, since they allow an adversary to
cause a predictable changes to the message.

\subsection{Composing PRGs}
Here, we are going to talk about two constructions that allow us to create new
PRGs from old PRGs. That approach allows us to increase the output size of a
PRG while preserving its security properties.

\subsubsection{A parallel construction}
Let $G$ be a PRG defined over $\cll{(S,R)}$. We can model the use of many uses
of $G$ as a new PRG $G'$, that is, we construct a new PRG $G'$ that applies $G$
to $n$ seeds and concatenates the outputs. This way, $G'$ is defined over
$(\cll{S}^n,\cll{R}^n)$, and for $s_1, ..., s_n \in \cll{S}$,
\[
  G'(s_1, ..., s_n) = G(s_1), ..., G(s_n)\text{.}
\]

We call $G'$ the \itl{$n$-wise parallel composition of $G$}, where $n$ is called
a \itl{repetition parameter of $G'$}.

\subsubsection{A sequential construction}
Let $G$ be a PRG defined over $\cll{(S,R \times S)}$. A \itl{Blum-Micali construction}
takes such PRG and constructs a new PRG $G'$ defined over $(\cll{S},\cll{R}^n \times \cll{S})$,
for every $n \geq 1$ that is poly-bounded. For $s \in \cll{S}$, we define
\begin{code}
G'(s) =
  s[0] = s
  for i in 1 to n
    r[i], s[i] = G(s[i - 1])
  r[1] + .. + r[n] + s[n]
\end{code}

We call $G'$ the \itl{$n$-wise sequential composition of $G$}.

\subsection{Case study of Salsa and ChaCha PRGs}
Salsa20/20\footnote{\verb|http://cr.yp.to/snuffle/design.pdf|} is a stream
cipher created in 2005 by Daniej Bernstein. ChaCha20\footnote{\verb|http://cr.yp.to/chacha/chacha-20080128.pdf|}
is its modification, proposed by him in 2008. In this part we will look into
PRGs underlying the Salsa and ChaCha algorithms. As those ciphers are 256-bit,
their PRGs naturally take the same input, and additionally a 64-bit nonce. The
PRGs make use of two main components --- a padding function, denoted $\text{pad}(s,j,n)$,
that combines a seed $s$ with a 64-bit counter $j$ and the nonce, and a fixed
permutation $\mathtt{perm} :  \set{\mtt{0},\mtt{1}}^{512} \to \set{\mtt{0},\mtt{1}}^{512}$.

These components are used to output $L$ pseudorandom block, each 512-bits long,
where $L \le 2^{64}$, using the following algorithm:

\begin{code}
for j in 0 to L
  h[j] = pad(s, j, n)
  r[j] = perm(h[j]) ^ h[j]
return r[0] + ... + r[L - 1]
\end{code}

where \verb|^| denotes the XOR operation. The final PRG output is $512 \times L$
bits long. Note, that in both Salsa and ChaCha the XOR operation on line 3 is a
slightly more complex --- the 512-bit operands $h_j$ and $\text{perm}(h_j)$ are
split into 16 32-bit long words and then added word-wise modulo $2^{32}$.

Here, we are going to briefly talk about how padding and permutation functions
work.

The padding function takes as an input 256-bit seed $s_0, ..., s_7 \in \set{\mtt{0},\mtt{1}}^{32}$,
a 64-bit counter $j_0, j_1 \in \set{\mtt{0},\mtt{1}}^{32}$, and a 64-bit nonce
$n_0, n_1 \in \set{\mtt{0},\mtt{1}}^{32}$. It outputs a 512-bit block denoted
$x_0, ..., x_{15} \in \set{\mtt{0},\mtt{1}}^{32}$. The output is arranged in a
$4 \times 4$ matrix of 32-bit words as follows:

\[
  \begin{bmatrix}
    x_0 & x_1 & x_2 & x_3 \\
    x_4 & x_5 & x_6 & x_7 \\
    x_8 & x_9 & x_{10} & x_{11} \\
    x_{12} & x_{13} & x_{14} & x_{15} \\
  \end{bmatrix} \leftarrow \begin{bmatrix}
    c_0 & c_1 & c_2 & c_3 \\
    s_0 & s_1 & s_2 & s_3 \\
    s_4 & s_5 & s_6 & s_7 \\
    j_0 & j_1 & n_0 & n_1 \\
  \end{bmatrix}
\]

where $c_0, ..., c_3$ are fixed 32-bit constants.

The permutation function is constructed by iterating a simple permutation a
fixed number of times. The 512-bit input is treated as a $4 \times 4$ matrix of
32-bit words denoted by $x_0, ..., x_{15}$. In ChaCha20 the permutation function
is implemented by repeating the following sequence of steps ten times:

\begin{multicols}{2}
  \begin{enumerate}
    \setlength\itemsep{1pt}
  \item \verb|quarter_round|($x_{0}, x_{4}, x_{8}, x_{12}$)
  \item \verb|quarter_round|($x_{1}, x_{5}, x_{9}, x_{13}$)
  \item \verb|quarter_round|($x_{2}, x_{6}, x_{10}, x_{14}$)
  \item \verb|quarter_round|($x_{3}, x_{7}, x_{11}, x_{15}$)
  \item \verb|quarter_round|($x_{0}, x_{5}, x_{10}, x_{15}$)
  \item \verb|quarter_round|($x_{1}, x_{6}, x_{11}, x_{12}$)
  \item \verb|quarter_round|($x_{2}, x_{7}, x_{8}, x_{13}$)
  \item \verb|quarter_round|($x_{3}, x_{4}, x_{9}, x_{14}$)
  \end{enumerate}
\end{multicols}

where \verb|quarter_round|($a, b, c, d$) is defined as:

\begin{code}
  a += b; d ^= a; d <<<= 16;
  c += d; b ^= c; b <<<= 12;
  a += b; d ^= a; d <<<= 8;
  c += d; b ^= c; b <<<= 7;
\end{code}

where \verb|<<<| is a left bit rotation operation. Observe, that the first four
calls to \verb|quarter_round| are applied to each of the four columns of the
$4 \times 4$ matrix, from left to right, and the next four are applied to each
of the four diagonals, with wrap around.

The last thing we should talk about are \itl{nonces}. While many of the PRGs we
have discussed so far took only the seed as an input, many real-world PRGs take
an additional input called a \itl{nonce}. Then, the PRG is a function $G : \cll{S} \times \cll{N} \to \cll{R}$,
where $\cll{S}$ and $\cll{R}$ as discussed before, and $\cll{N}$ is called a
\itl{nonce space}. The nonce allows us to generate multiple pseudorandom outputs
from a signle seed $s$. Such nonce turns the pseudorandom generator into a more
powerful, but complex, primitive called a \itl{pseudorandom function}, which we
are going to discuss in the next sections. Nonces make it possible to use the
same seed to generate multiple random outputs, and encrypt multiple messages
without loosing the encryption strength.

\section{Block ciphers}

\begin{epigraph}{Cory Doctorow, \itl{Schneier's Law}}
  Any person can invent a security system so clever that she or he canâ€™t think
  of how to break it.
\end{epigraph}

\end{document}